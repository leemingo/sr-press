"""Implements the features used in exPressComponent."""
import os
import sys
base_path = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
sys.path.append(base_path)

import math
from functools import partial, reduce, wraps
from typing import Callable, List, Optional, no_type_check

import numpy as np
import pandas as pd

import express.config as config
from express.databases import Database
from express.databases.base import TABLE_ACTIONS
from express.utils import add_names, play_left_to_right

_spadl_cfg = {
    "length": 105,
    "width": 68,
    "penalty_box_length": 16.5,
    "penalty_box_width": 40.3,
    "six_yard_box_length": 5.5,
    "six_yard_box_width": 18.3,
    "goal_width": 7.32,
    "penalty_spot_distance": 11,
    "goal_length": 2,
    "origin_x": 0,
    "origin_y": 0,
    "circle_radius": 9.15,
}

_goal_x: float = _spadl_cfg["length"]
_goal_y: float = _spadl_cfg["width"] / 2

_pass_like = [
    "pass",
    "cross",
    "throw_in",
    "freekick_crossed",
    "freekick_short",
    "corner_crossed",
    "corner_short",
    "goalkick",
]

def required_fields(fields):
    def decorator(func):
        func.required_fields = fields
        return func

    return decorator

def feature_column_names(fs: List[Callable], nb_prev_actions: int = 3) -> List[str]:
    """Return the names of the features generated by a list of transformers.

    Parameters
    ----------
    fs : list(callable)
        A list of feature transformers.
    nb_prev_actions : int, default=3
        The number of previous actions included in the game state.

    Returns
    -------
    list(str)
        The name of each generated feature.
    """

    cols = TABLE_ACTIONS + ["type_name", "result_name", "bodypart_name"]
    dummy_actions = pd.DataFrame(np.zeros((10, len(cols))), columns=cols).set_index(
        ["game_id", "action_id"]
    )

    for c in cols:
        if "name" in c:
            dummy_actions[c] = dummy_actions[c].astype(str)

    gs = gamestates(dummy_actions, nb_prev_actions)  # type: ignore

    return list(pd.concat([f(gs) for f in fs], axis=1).columns.values)

def gamestates(actions, nb_prev_actions: int = 3):
    r"""Convert a dataframe of actions to gamestates.

    Each gamestate is represented as the <nb_prev_actions> previous actions.

    The list of gamestates is internally represented as a list of actions
    dataframes :math:`[a_0,a_1,\ldots]` where each row in the a_i dataframe contains the
    previous action of the action in the same row in the :math:`a_{i-1}` dataframe.

    Parameters
    ----------
    actions : Actions
        A DataFrame with the actions of a game.
    nb_prev_actions : int, default=3  # noqa: DAR103
        The number of previous actions included in the game state.

    Raises
    ------
    ValueError
        If the number of actions is smaller 1.

    Returns
    -------
    GameStates
         The <nb_prev_actions> previous actions for each action.
    """

    if nb_prev_actions < 0:
        raise ValueError("The game state should include at least zero preceding action.")
    states = [actions]
    for i in range(1, nb_prev_actions):
        # Issue 1: List-type columns like ['visible_area_360', 'freeze_frame_360'] raise TypeError during interpolation.
        # socceraction module update on 24.06.23 introduced an error when interpolating these columns:
        # https://github.com/ML-KULeuven/socceraction/commit/e9c398ea50219eb6eb188c44c35ad70b7fd79cc6
        
        # Issue 2: All events missing 'freeze_frame_360' are interpolated unintentionally.
        # The intended logic was to interpolate only the first event in each half, but other events without freeze_frame_360' are also filled with x.iloc[0], causing incorrect interpolations.                                                                              
        # prev_actions = actions.groupby(["game_id", "period_id"], sort=False, as_index=False).apply(
        #     lambda x: x.shift(i, fill_value=float("nan")).fillna(x.iloc[0])  # noqa: B023
        # )

        group_actions = actions.groupby(['game_id', 'period_id'], sort=False, as_index=False, group_keys=False)
        prev_actions = group_actions.apply(lambda x: x.shift(i))
        fill_indices = group_actions.head(i).index # First i rows per group get NaN, fill with original values
        prev_actions.loc[fill_indices] = actions.loc[fill_indices]

        states.append(prev_actions)  

    return states

@no_type_check
def simple(actionfn: Callable):
    """Make a function decorator to apply actionfeatures to game states.

    Parameters
    ----------
    actionfn : Callable
        A feature transformer that operates on actions.

    Returns
    -------
    FeatureTransfomer
        A feature transformer that operates on game states.
    """

    @wraps(actionfn)
    def _wrapper(gamestates) -> pd.DataFrame:
        if not isinstance(gamestates, (list,)):
            gamestates = [gamestates]
        X = []
        for i, a in enumerate(gamestates):
            Xi = actionfn(a)
            Xi.columns = [c + "_a" + str(i) for c in Xi.columns]
            X.append(Xi)
        return pd.concat(X, axis=1)

    return _wrapper


@required_fields(["type_id"])
@simple
def actiontype(actions):
    """Get the type of each action.

    Parameters
    ----------
    actions : Actions
        The actions of a game.

    Returns
    -------
    Features
        The 'type_name' of each action.
    """
    X = pd.DataFrame(index=actions.index)
    X["actiontype"] = pd.Categorical(
        actions["type_id"].replace(config.actiontypes_df().type_name.to_dict()),
        categories=config.actiontypes,
        ordered=False,
    )
    return X

@required_fields(["type_name"])
@simple
def actiontype_onehot(actions):
    """Get the one-hot-encoded type of each action.

    Parameters
    ----------
    actions : pd.DataFrame
        The actions of a game.

    Returns
    -------
    pd.DataFrame
        A one-hot encoding of each action's type.
    """
    X = pd.DataFrame()
    for type_name in config.actiontypes:
        col = 'type_' + type_name
        X[col] = actions['type_name'] == type_name
    return X

@required_fields(["result_id"])
@simple
def result(actions):
    """Get the result of each action.

    Parameters
    ----------
    actions : Actions
        The actions of a game.

    Returns
    -------
    Features
        The 'result_name' of each action.
    """

    X = pd.DataFrame(index=actions.index)
    X["result"] = pd.Categorical(
        actions["result_id"].replace(config.results_df().result_name.to_dict()),
        categories=config.results,
        ordered=False,
    )
    return X

@required_fields(["result_name"])
@simple
def result_onehot(actions):
    """Get the one-hot-encode result of each action.

    Parameters
    ----------
    actions : pd.DataFrame
        The actions of a game.

    Returns
    -------
    pd.DataFrame
        The one-hot encoding of each action's result.
    """
    X = pd.DataFrame()
    for result_name in config.results:
        col = 'result_' + result_name
        X[col] = actions['result_name'] == result_name
    return X

@required_fields(["bodypart_id"])
@simple
def bodypart(actions):
    """Get the body part used to perform each action.

    Parameters
    ----------
    actions : Actions
        The actions of a game.

    Returns
    -------
    Features
        The 'bodypart_name' of each action.
    """

    X = pd.DataFrame(index=actions.index)
    foot_id = config.bodyparts.index("foot")
    left_foot_id = config.bodyparts.index("foot_left")
    right_foot_id = config.bodyparts.index("foot_right")
    X["bodypart"] = pd.Categorical(
        actions["bodypart_id"]
        .replace([left_foot_id, right_foot_id], foot_id)
        .replace(config.bodyparts_df().bodypart_name.to_dict()),
        categories=["foot", "head", "other", "head/other"],
        ordered=False,
    )
    return X

@required_fields(["bodypart_name"])
@simple
def bodypart_onehot(actions):
    """Get the one-hot-encoded bodypart of each action.

    Parameters
    ----------
    actions : pd.DataFrame
        The actions of a game.

    Returns
    -------
    pd.DataFrame
        The one-hot encoding of each action's bodypart.
    """
    X = pd.DataFrame()
    for bodypart_name in config.bodyparts:
        col = 'bodypart_' + bodypart_name
        X[col] = actions['bodypart_name'] == bodypart_name
    return X

@required_fields(["period_id", "time_seconds"])
@simple
def time(actions):
    """Get the time when each action was performed.

    This generates the following features:
        :period_id:
            The ID of the period.
        :time_seconds:
            Seconds since the start of the period.
        :time_seconds_overall:
            Seconds since the start of the game. Stoppage time during previous
            periods is ignored.

    Parameters
    ----------
    actions : pd.DataFrame
        The actions of a game.

    Returns
    -------
    pd.DataFrame
        The 'period_id', 'time_seconds' and 'time_seconds_overall' when each
        action was performed.
    """
    timedf = actions[['period_id', 'time_seconds']].copy()
    timedf['time_seconds_overall'] = ((timedf.period_id - 1) * 45 * 60) + timedf.time_seconds
    return timedf

@required_fields(["period_id", "time_seconds"])
@simple
def end_time(actions):
    """Get the time when each action was performed.

    This generates the following features:
        :period_id:
            The ID of the period.
        :time_seconds:
            Seconds since the start of the period.
        :time_seconds_overall:
            Seconds since the start of the game. Stoppage time during previous
            periods is ignored.

    Parameters
    ----------
    actions : pd.DataFrame
        The actions of a game.

    Returns
    -------
    pd.DataFrame
        The 'period_id', 'time_seconds' and 'time_seconds_overall' when each
        action was performed.
    """
    timedf = pd.DataFrame()
    timedf["duration"] = actions["duration"]
    timedf["end_time_seconds"] = actions["duration"] + actions["time_seconds"]

    return timedf

@required_fields(["start_x", "start_y"])
@simple
def startlocation(actions):
    """Get the location where each action started.

    Parameters
    ----------
    actions : pd.DataFrame
        The actions of a game.

    Returnss
    -------
    pd.DataFrame
        The 'start_x' and 'start_y' location of each action.
    """
    return actions[['start_x', 'start_y']]


@required_fields(["end_x", "end_y"])
@simple
def endlocation(actions):
    """Get the location where each action ended.

    Parameters
    ----------
    actions : pd.DataFrame
        The actions of a game.

    Returns
    -------
    pd.DataFrame
        The 'end_x' and 'end_y' location of each action.
    """
    return actions[['end_x', 'end_y']]

@required_fields(["start_x", "start_y"])
@simple
def startpolar(actions):
    """Get the polar coordinates of each action's start location.

    The center of the opponent's goal is used as the origin.

    Parameters
    ----------
    actions : pd.DataFrame
        The actions of a game.

    Returns
    -------
    pd.DataFrame
        The 'start_dist_to_goal' and 'start_angle_to_goal' of each action.
    """
    polardf = pd.DataFrame()
    dx = abs(_goal_x - actions['start_x'])
    dy = abs(_goal_y - actions['start_y'])
    polardf['start_dist_to_goal'] = np.sqrt(dx ** 2 + dy ** 2)
    with np.errstate(divide='ignore', invalid='ignore'):
        polardf['start_angle_to_goal'] = np.nan_to_num(np.arctan(dy / dx))
    return polardf


@required_fields(["end_x", "end_y"])
@simple
def endpolar(actions):
    """Get the polar coordinates of each action's end location.

    The center of the opponent's goal is used as the origin.

    Parameters
    ----------
    actions : pd.DataFrame
        The actions of a game.

    Returns
    -------
    pd.DataFrame
        The 'start_dist_to_goal' and 'start_angle_to_goal' of each action.
    """
    polardf = pd.DataFrame()
    dx = abs(_goal_x - actions['end_x'])
    dy = abs(_goal_y - actions['end_y'])
    polardf['end_dist_to_goal'] = np.sqrt(dx ** 2 + dy ** 2)
    with np.errstate(divide='ignore', invalid='ignore'):
        polardf['end_angle_to_goal'] = np.nan_to_num(np.arctan(dy / dx))
    return polardf

@required_fields(["start_x", "start_y", "end_x", "end_y"])
@simple
def movement(actions):
    """Get the distance covered by each action.

    Parameters
    ----------
    actions : pd.DataFrame
        The actions of a game.

    Returns
    -------
    pd.DataFrame
        The horizontal ('dx'), vertical ('dy') and total ('movement') distance
        covered by each action.
    """
    mov = pd.DataFrame()
    mov['dx'] = actions.end_x - actions.start_x
    mov['dy'] = actions.end_y - actions.start_y
    mov['movement'] = np.sqrt(mov.dx ** 2 + mov.dy ** 2)
    return mov

@required_fields(["team_id"])
# @fs.simple: STATE FEATURES
def team(gamestates):
    """Check whether the possession changed during the game state.

    For each action in the game state, True if the team that performed the
    action is the same team that performed the last action of the game state;
    otherwise False.

    Parameters
    ----------
    gamestates : pd.DataFrame
        The game states of a game.

    Returns
    -------
    pd.DataFrame
        A dataframe with a column 'team_ai' for each <nb_prev_actions> indicating
        whether the team that performed action a0 is in possession.
    """
    a0 = gamestates[0]
    teamdf = pd.DataFrame()
    for i, a in enumerate(gamestates[1:]):
        teamdf['team_' + (str(i + 1))] = a.team_id == a0.team_id
    return teamdf

@required_fields(["time_seconds"])
#@fs.simple: STATE FEATURES
def time_delta(gamestates):
    """Get the number of seconds between the last and previous actions.

    Parameters
    ----------
    gamestates : pd.DataFrame
        The game states of a game.

    Returns
    -------
    pd.DataFrame
        A dataframe with a column 'time_delta_i' for each <nb_prev_actions>
        containing the number of seconds between action ai and action a0.
    """
    a0 = gamestates[0]
    dt = pd.DataFrame()
    for i, a in enumerate(gamestates[1:]):
        dt['time_delta_' + (str(i + 1))] = a0.time_seconds - a.time_seconds
    return dt

@required_fields([["start_x", "start_y", "end_x", "end_y"]])
#@fs.simple: : STATE FEATURES
def space_delta(gamestates):
    """Get the distance covered between the last and previous actions.

    Parameters
    ----------
    gamestates : pd.DataFrame
        The gamestates of a game.

    Returns
    -------
    pd.DataFrame
        A dataframe with a column for the horizontal ('dx_a0i'), vertical
        ('dy_a0i') and total ('mov_a0i') distance covered between each
        <nb_prev_actions> action ai and action a0.
    """
    a0 = gamestates[0]
    spaced = pd.DataFrame()
    for i, a in enumerate(gamestates[1:]):
        dx = a.end_x - a0.start_x
        spaced['dx_a0' + (str(i + 1))] = dx
        dy = a.end_y - a0.start_y
        spaced['dy_a0' + (str(i + 1))] = dy
        spaced['mov_a0' + (str(i + 1))] = np.sqrt(dx ** 2 + dy ** 2)
    return spaced

@required_fields([["team_id", "type_name", "result_id"]])
#@fs.simple: STATE FEATURES
def goalscore(gamestates):
    """Get the number of goals scored by each team after the action.

    Parameters
    ----------
    gamestates : pd.DataFrame
        The gamestates of a game.

    Returns
    -------
    pd.DataFrame
        The number of goals scored by the team performing the last action of the
        game state ('goalscore_team'), by the opponent ('goalscore_opponent'),
        and the goal difference between both teams ('goalscore_diff').
    """
    actions = gamestates[0]
    teamA = actions['team_id'].values[0]
    goals = actions['type_name'].str.contains('shot') & (
        actions['result_id'] == config.results.index('success')
    )
    owngoals = actions['type_name'].str.contains('shot') & (
        actions['result_id'] == config.results.index('owngoal')
    )
    teamisA = actions['team_id'] == teamA
    teamisB = ~teamisA
    goalsteamA = (goals & teamisA) | (owngoals & teamisB)
    goalsteamB = (goals & teamisB) | (owngoals & teamisA)
    goalscoreteamA = goalsteamA.cumsum() - goalsteamA
    goalscoreteamB = goalsteamB.cumsum() - goalsteamB

    scoredf = pd.DataFrame()
    scoredf['goalscore_team'] = (goalscoreteamA * teamisA) + (goalscoreteamB * teamisB)
    scoredf['goalscore_opponent'] = (goalscoreteamB * teamisA) + (goalscoreteamA * teamisB)
    scoredf['goalscore_diff'] = scoredf['goalscore_team'] - scoredf['goalscore_opponent']
    return scoredf

@required_fields(["start_x", "start_y"])
@simple
def relative_startlocation(actions):
    """Get the location where each action started relative to the sideline and goalline.

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.

    Returns
    -------
    Features
        The 'start_dist_sideline' and 'start_dist_goalline' of each action.
    """
    actions["_start_dist_sideline"] = _spadl_cfg["width"] - actions["start_y"]
    actions["start_dist_sideline"] = actions[["_start_dist_sideline", "start_y"]].min(axis=1)
    actions["start_dist_goalline"] = _spadl_cfg["length"] - actions["start_x"]
    return actions[["start_dist_sideline", "start_dist_goalline"]]

@required_fields(["end_x", "end_y"])
@simple
def relative_endlocation(actions):
    """Get the location where each action ended relative to the sideline and goalline.

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.

    Returns
    -------
    Features
        The 'end_dist_sideline' and 'end_dist_goalline' of each action.
    """
    actions["_end_dist_sideline"] = _spadl_cfg["width"] - actions["end_y"]
    actions["end_dist_sideline"] = actions[["_end_dist_sideline", "end_y"]].min(axis=1)
    actions["end_dist_goalline"] = _spadl_cfg["length"] - actions["end_x"]
    return actions[["end_dist_sideline", "end_dist_goalline"]]

@required_fields(["start_x", "start_y", "end_x", "end_y"])
@simple
def angle(actions):
    """Get the angle between the start and end location of an action.

    The action's start location is used as the origin in a polar coordinate
    system with the polar axis parallell to the the goalline.

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.

    Returns
    -------
    Features
        The 'angle' of each action.
    """
    polardf = pd.DataFrame(index=actions.index)
    dx = (actions["end_x"] - actions["start_x"]).values
    dy = (actions["end_y"] - actions["start_y"]).values
    with np.errstate(divide="ignore", invalid="ignore"):
        polardf["angle"] = np.nan_to_num(np.arctan(dy / dx))
    polardf.loc[actions["end_x"] < actions["start_x"], "angle"] += np.pi
    return polardf


@required_fields(["start_x", "start_y", "end_x", "end_y", "time_seconds"])
def speed(gamestates):
    """Get the speed at which the ball moved during the previous actions.

    Parameters
    ----------
    gamestates : GameStates
        The game states of a game.

    Returns
    -------
    Features
        A dataframe with columns 'speedx_a0i', 'speedy_a0i', 'speed_a0i'
        for each <nb_prev_actions> containing the ball speed in m/s  between
        action ai and action a0.
    """
    a0 = gamestates[0]
    speed = pd.DataFrame(index=a0.index)
    for i, a in enumerate(gamestates[1:]):
        dx = a.end_x - a0.start_x
        dy = a.end_y - a0.start_y
        dt = a0.time_seconds - a.time_seconds
        dt[dt <= 0] = 1e-6
        speed["speedx_a0" + (str(i + 1))] = dx.abs() / dt
        speed["speedy_a0" + (str(i + 1))] = dy.abs() / dt
        speed["speed_a0" + (str(i + 1))] = np.sqrt(dx**2 + dy**2) / dt
    return speed

@required_fields(["freeze_frame_360"])
@simple
def freeze_frame_360(actions):
    """Get the raw StatsBomb 360 freeze frame.

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.

    Returns
    -------
    Features
        The 'freeze_frame_360' of each action.
    """
    if "freeze_frame_360" not in actions.columns:
        df = pd.DataFrame(index=actions.index)
        df["freeze_frame_360"] = None
        return df
    return actions[["freeze_frame_360"]]

@required_fields(["under_pressure"])
@simple
def under_pressure(actions):
    """Get the value of StatsBomb's 'under_pressure' attribute.

    Every on-the-ball event that overlaps the duration of a pressure event is
    annotated as being 'under_pressure'. For example, if a pressure
    event appears before a pass, and the pressure’s timestamp plus its
    duration encompasses the pass’s timestamp, that pass is said to have been
    made under pressure. If a pressure event occurs after a pass, but before
    the end of the pass (as calculated by using its duration), that pass is
    said to have been received under pressure. Events which are naturally
    performed under pressure like duels, dribbles etc, all pick up the
    attribute, even in the absence of an actual pressure event. Carries can be
    pressured not just by pressure events, but other defensive events (defined
    in change 2.) that happen during or at the end of the carry

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.

    Returns
    -------
    Features
        The 'under_pressure' attribute of each action.
    """
    return actions[["under_pressure"]].fillna(False)

@required_fields(["extra"])
@simple
def ball_height_onehot(actions):
    """Get the one_hot_encoded height of a pass.

    The height is defined as:
        - "ground": ball doesn’t come off the ground.
        - "low": ball comes off the ground but is under shoulder level at peak height.
        - "high": ball goes above shoulder level at peak height.

    This feature is only defined for pass-like actions.

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.

    Returns
    -------
    Features
        The ball height during each pass-like action.
    """
    df = pd.DataFrame(index=actions.index)
    df["ball_height_ground"] = False
    df["ball_height_low"] = False
    df["ball_height_high"] = False
    passes = actions[actions.type_name.isin(_pass_like)]
    for idx, pas in passes.iterrows():
        pass_height = pas["extra"]["pass"].get("height", {"name": None}).get("name")
        if pass_height == "Ground Pass":
            df.at[idx, "ball_height_ground"] = True
        elif pass_height == "Low Pass":
            df.at[idx, "ball_height_low"] = True
        elif pass_height == "High Pass":
            df.at[idx, "ball_height_high"] = True
    return df

def _is_inside_triangle(pnt, triangle):
    """Compute whether the given point is in the given triangle.

    Parameters
    ----------
    pnt : tuple (x, y)
        The given point.

    triangle : list of tuples [(x0, y0), (x1, y1), (x2, y2)]
        The corners of the triangle, clockwise.

    Returns
    -------
        Boolean
    """

    def _is_right_of(line):
        return (
            (line[1][0] - line[0][0]) * (pnt[1] - line[0][1])
            - (pnt[0] - line[0][0]) * (line[1][1] - line[0][1])
        ) <= 0

    return (
        _is_right_of([triangle[0], triangle[1]])
        & _is_right_of([triangle[1], triangle[2]])
        & _is_right_of([triangle[2], triangle[0]])
    )

def _get_passing_cone(start, end, dist=1):
    """Compute the corners of the triangular passing cone between the given start and end location.

    The cone starts at the start location and has a width of 2*dist at the end location, with the end location
    indicating the middle of the line that connects the two adjacent corners.

    Parameters
    ----------
    start : tuple (x, y)
        The given start location.

    end : tuple (x, y)
        The given end location.

    dist : int
        The distance between the end location and its two adjacent corners of the triangle.

    Returns
    -------
    List of tuples [(x0, y0), (x1, y1), (x2, y2)] containing the corners of the triangle, clockwise.

    """
    if (start[0] == end[0]) | (start[1] == end[1]):
        slope = 0
    else:
        slope = (end[1] - start[1]) / (end[0] - start[0])

    dy = math.sqrt(dist**2 / (slope**2 + 1))
    dx = -slope * dy

    if start[0] == end[0]:  # have treated vertical line as horizontal one, rotate
        dx, dy = dy, dx

    pnt1 = (end[0] + dx, end[1] + dy)
    pnt2 = (end[0] - dx, end[1] - dy)
    return [start, pnt1, pnt2]


@required_fields(["freeze_frame_360", "start_x", "start_y", "end_x", "end_y"])
@simple
def nb_opp_in_path(actions, path_width: int = 1):
    """Get the number of opponents in the path between the start and end location of a pass.

    The path is defined as a triangular corridor between the pass origin and
    the receiver's location with a base of `x` meters at the receiver's
    location.

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.
    path_width : float
        The width (in meters) of the triangular path at the receiver's location.

    Returns
    -------
    Features
        The number of opponents in the path of each pass.
    """
    df = pd.DataFrame(index=actions.index)
    df["nb_opp_in_path"] = 0

    passes = actions[actions.type_name.isin(_pass_like)]
    for idx, pas in passes.iterrows():
        if not pas["freeze_frame_360"]:
            continue

        start_coo = [pas["start_x"], pas["start_y"]]
        end_coo = [pas["end_x"], pas["end_y"]]

        if start_coo == end_coo:
            continue

        opponents_coo = [(o["x"], o["y"]) for o in pas["freeze_frame_360"] if not o["teammate"]]
        triangle = _get_passing_cone(start_coo, end_coo, path_width)
        df.at[idx, "nb_opp_in_path"] = sum(_is_inside_triangle(o, triangle) for o in opponents_coo)
    return df

@required_fields(["freeze_frame_360", "start_x", "start_y", "end_x", "end_y"])
@simple
def packing_rate(actions):
    """Get the number of defenders that are outplayed by a pass.

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.

    Returns
    -------
    Features
        The number of defenders outplayed by a pass.
    """
    df = pd.DataFrame(index=actions.index)
    df["packing_rate"] = 0

    goal_coo = np.array([_goal_x, _goal_y])

    passes = actions[actions.type_name.isin(_pass_like)]
    for idx, pas in passes.iterrows():
        if not pas["freeze_frame_360"]:
            continue

        opponents_coo = np.array(
            [(o["x"], o["y"]) for o in pas["freeze_frame_360"] if not o["teammate"]]
        )
        if len(opponents_coo) == 0:
            continue

        ball_coo = np.array([pas["start_x"], pas["start_y"]])
        end_coo = np.array([pas["end_x"], pas["end_y"]])

        dist_ball_goal = np.sqrt(
            (goal_coo[0] - ball_coo[0]) ** 2 + (goal_coo[1] - ball_coo[1]) ** 2
        )
        dist_destination_goal = np.sqrt(
            (goal_coo[0] - end_coo[0]) ** 2 + (goal_coo[1] - end_coo[1]) ** 2
        )
        dist_def_goal = np.sqrt(
            (opponents_coo[:, 0] - goal_coo[0]) ** 2 + (opponents_coo[:, 1] - goal_coo[1]) ** 2
        )
        outplayed = (
            # The defender is between the ball and the goal before the pass
            (dist_def_goal <= dist_ball_goal)
            # The defender is further from the goal than the ball after the pass
            & (dist_def_goal > dist_destination_goal)
            # The ball moved closer to the goal
            & (dist_destination_goal <= dist_ball_goal)
        )
        df.at[idx, "packing_rate"] = np.sum(outplayed)
    return df

def _opponents_in_radius(actions, radius: int = 1):
    """Get the number of opponent (player under pressure: attacker) in a radius around the action's start and end location.
    
    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.
    radius : int
        The radius (in meters) of the circle in which defenders are counted.

    Returns
    -------
    Features
        The number of defenders is a radius around the actions start and end location.
    """
    defenders_in_radius = np.zeros((len(actions), 2), dtype=int)
    for i, (_, action) in enumerate(actions.iterrows()):
        if not action["freeze_frame_360"]:
            continue

        opponents_coo = np.array(
            [(o["x"], o["y"]) for o in action["freeze_frame_360"] if not o["teammate"]]
        )
        if len(opponents_coo) == 0:
            continue

        start_coo = np.array([action["start_x"], action["start_y"]])
        end_coo = np.array([action["end_x"], action["end_y"]])

        # Distance to start location
        dist_defender_start = np.sqrt(
            (opponents_coo[:, 0] - start_coo[0]) ** 2 + (opponents_coo[:, 1] - start_coo[1]) ** 2
        )
        defenders_in_radius[i, 0] = np.sum(dist_defender_start <= radius)

        # Distance to end location
        dist_defender_end = np.sqrt(
            (opponents_coo[:, 0] - end_coo[0]) ** 2 + (opponents_coo[:, 1] - end_coo[1]) ** 2
        )
        defenders_in_radius[i, 1] = np.sum(dist_defender_end <= radius)

    return pd.DataFrame(
        defenders_in_radius,
        index=actions.index,
        columns=[f"nb_defenders_start_{radius}m", f"nb_defenders_end_{radius}m"],
    )

@required_fields(["freeze_frame_360", "start_x", "start_y", "end_x", "end_y"])
@simple
def dist_opponent(actions):
    """Get the distance to the nearest defender.

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.

    Returns
    -------
    Features
        The distance to the nearest defender at the start and end location of the action,
        and along the action's path.
    """

    dist = np.ones((len(actions), 3), dtype=float) * 20
    for i, (_, action) in enumerate(actions.iterrows()):
        if not action["freeze_frame_360"]:
            continue

        opponents_coo = np.array([(o["x"], o["y"]) for o in action["freeze_frame_360"] if not o["teammate"]])
        if len(opponents_coo) == 0:
            continue

        start_coo = np.array([action["start_x"], action["start_y"]])
        end_coo = np.array([action["end_x"], action["end_y"]])

        # Distance to start location
        dist[i, 0] = np.amin(
            np.sqrt(
                (opponents_coo[:, 0] - start_coo[0]) ** 2
                + (opponents_coo[:, 1] - start_coo[1]) ** 2
            )
        )

        # Distance to end location
        dist[i, 1] = np.amin(
            np.sqrt(
                (opponents_coo[:, 0] - end_coo[0]) ** 2 + (opponents_coo[:, 1] - end_coo[1]) ** 2
            )
        )

        # Distance to action path
        # normalized tangent vector
        if (start_coo == end_coo).all():
            dist[i, 2] = dist[i, 0]
        else:
            d = np.divide(end_coo - start_coo, np.linalg.norm(end_coo - start_coo))
            # signed parallel distance components
            s = np.dot(start_coo - opponents_coo, d)
            t = np.dot(opponents_coo - end_coo, d)
            # clamped parallel distance
            h = np.maximum.reduce([s, t, np.zeros(len(opponents_coo))])
            # perpendicular distance component, as before
            # note that for the 3D case these will be vectors
            c = np.cross(opponents_coo - start_coo, d)
            # use hypot for Pythagoras to improve accuracy
            dist[i, 2] = np.amin(np.hypot(h, c))

    return pd.DataFrame(
        dist,
        index=actions.index,
        columns=["dist_defender_start", "dist_defender_end", "dist_defender_action"],
    )

def closest_players(actions, num_players=3):
    """For each action, find the n closest teammates and n closest opponents to the action's location.

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.
    num_players (int): Number of closest teammates and opponents to find for each action.

    Returns:
    - DataFrame: Contains x, y, and distance for each of the closest teammates and opponents.
    """
    # Get the n closest teammates and opponents
    num_teammates = num_players if num_players < 11 else 10 # Exclude event player
    num_opponents = num_players
    cloeset_teammates_xy = np.full((len(actions), num_teammates*3), np.nan, dtype=float) # x, y, distance for each teammate player
    cloeset_opponents_xy = np.full((len(actions), num_opponents*3), np.nan, dtype=float) # x, y, distance for each opponent player
    
    for i, action in enumerate(actions.itertuples(index=False)):
        if not action.freeze_frame_360:
            continue
        
        freeze_frame = pd.DataFrame.from_records(action.freeze_frame_360)
        start_x, start_y = action.start_x, action.start_y
        teammate_locs = freeze_frame[freeze_frame.teammate & ~freeze_frame.actor].copy() # Exclude event player
        opponent_locs = freeze_frame[~freeze_frame.teammate].copy()

        teammate_locs['distance'] = np.hypot(teammate_locs.x - start_x, teammate_locs.y - start_y)
        opponent_locs['distance'] = np.hypot(opponent_locs.x - start_x, opponent_locs.y - start_y)

        closest_teammates_df = teammate_locs.nsmallest(num_teammates, 'distance')[['x', 'y', 'distance']]
        closest_opponents_df = opponent_locs.nsmallest(num_opponents, 'distance')[['x', 'y', 'distance']]

        for j in range(len(closest_teammates_df)):
            cloeset_teammates_xy[i, j * 3] = closest_teammates_df.iloc[j]['x']
            cloeset_teammates_xy[i, j * 3 + 1] = closest_teammates_df.iloc[j]['y']
            cloeset_teammates_xy[i, j * 3 + 2] = closest_teammates_df.iloc[j]['distance']

        for j in range(len(closest_opponents_df)):
            cloeset_opponents_xy[i, j * 3] = closest_opponents_df.iloc[j]['x']
            cloeset_opponents_xy[i, j * 3 + 1] = closest_opponents_df.iloc[j]['y']
            cloeset_opponents_xy[i, j * 3 + 2] = closest_opponents_df.iloc[j]['distance']

    # Combine teammate and opponent data
    cloeset_xy = np.hstack((cloeset_teammates_xy, cloeset_opponents_xy))

    # Generate column names dynamically
    columns = []
    for k in range(1, num_teammates + 1):
        columns.extend([f"teammate_{k}_x", f"teammate_{k}_y", f"teammate_{k}_distance"])
    for k in range(1, num_opponents + 1):
        columns.extend([f"opponent_{k}_x", f"opponent_{k}_y", f"opponent_{k}_distance"])

    return pd.DataFrame(cloeset_xy, index=actions.index, columns=columns)

@required_fields(["freeze_frame_360", "start_x", "start_y"])
def expected_receiver_and_presser_by_distance(actions, min_players=3):
    distances = np.full((len(actions), min_players*2), np.nan, dtype=float)
    angles = np.full((len(actions), min_players*2), np.nan, dtype=float)

    for i, action in enumerate(actions.itertuples(index=False)):
        if not action.freeze_frame_360:
            continue
        
        freeze_frame = pd.DataFrame.from_records(action.freeze_frame_360)
        start_x, start_y = action.start_x, action.start_y
        teammate_locs = freeze_frame[freeze_frame.teammate & ~freeze_frame.actor & ~freeze_frame.keeper].reset_index(drop=True) # Exclude event player
        opponent_locs = freeze_frame[~freeze_frame.teammate & ~freeze_frame.keeper].reset_index(drop=True)

        if (len(teammate_locs) < min_players) or (len(opponent_locs) < min_players):
            continue
        
        # Calculate the closest opponent to the start location(presser)
        # np.hypot: Calculate Euclidean distance
        dist_presser_to_target = np.hypot(opponent_locs.x - start_x, opponent_locs.y - start_y)
        target_idx = np.argmin(dist_presser_to_target)
        target_x, target_y = opponent_locs.loc[target_idx, ["x", "y"]].values
       
        # expected-receiver
        dists_to_target = np.hypot(opponent_locs.x - target_x, opponent_locs.y - target_y)
        expected_receiver_idxs = np.argsort(dists_to_target)[:min_players] # Include the target itself
        expected_receivers_locs = opponent_locs.loc[expected_receiver_idxs, ["x", "y"]].values

        # expected-presser
        expected_pressers_idx = []
        for expected_receiver_idx in expected_receiver_idxs:
            receiver_x, receiver_y = opponent_locs.loc[expected_receiver_idx, ["x", "y"]].values

            # Note: Multiple pressers may target the same receiver.
            dists_to_receiver = np.hypot(teammate_locs.x - receiver_x, teammate_locs.y - receiver_y)

            presser_idx = np.argmin(dists_to_receiver)
            expected_pressers_idx.append(presser_idx) 
        expected_presser_locs = teammate_locs.iloc[expected_pressers_idx][["x", "y"]].values

        # Compute distances and angles between presser and expected receivers
        distances[i, :min_players] = np.hypot(expected_receivers_locs[:, 0] - start_x, expected_receivers_locs[:, 1] - start_y)
        angles[i, :min_players] = np.arctan2(expected_receivers_locs[:, 0] - start_x, expected_receivers_locs[:, 1] - start_y)

        # Compute distances and angles between presser and expected presser
        distances[i, min_players:] = np.hypot(expected_presser_locs[:, 0] - start_x, expected_presser_locs[:, 1] - start_y)
        angles[i, min_players:] = np.arctan2(expected_presser_locs[:, 0] - start_x, expected_presser_locs[:, 1] - start_y)

    distance_columns = (
        [f"distance_to_expected_receiver{idx}" for idx in range(1, min_players+1)]
        + [f"distance_to_expected_presser{idx}" for idx in range(1, min_players+1)]
    )
    angle_columns = (
        [f"angle_to_expected_receiver{idx}" for idx in range(1, min_players+1)]
        + [f"angle_to_expected_presser{idx}" for idx in range(1, min_players+1)]
    )

    # Create DataFrames for distances and angles
    distances_df = pd.DataFrame(distances, index=actions.index, columns=distance_columns)
    angles_df = pd.DataFrame(angles, index=actions.index, columns=angle_columns)

    return pd.concat([distances_df, angles_df], axis=1)

class SectorAnalysis:
    def __init__(self, ball_x, ball_y, freeze_frame, angle=45, player_idx=0,visualize=False):
        self.freeze_frame = freeze_frame
        self.angle = angle        
        self.player_idx = player_idx

        self.teammate = freeze_frame[player_idx]        
        self.visualize = visualize
        self.opponents_in_sector = []
        self.Z = None
        self.ball_x = ball_x
        self.ball_y = ball_y
        

    def calculate_opponents_in_sector(self):
        # Filter opponents within the sector and calculate distance and angle

        baseline_angle = np.arctan2(self.teammate['y'] - self.ball_y, self.teammate['x'] - self.ball_x)
        distance = ((self.teammate['x'] - self.ball_x) ** 2 + (self.teammate['y'] - self.ball_y) ** 2) ** 0.5
        
        for player in self.freeze_frame:
            if player['teammate']:  # Filter only opponent players
                px, py = player['x'], player['y']
                angle_to_player = np.arctan2(py - self.ball_y, px - self.ball_x)
                angle_diff = baseline_angle - angle_to_player
                angle_diff = (angle_diff + np.pi) % (2 * np.pi) - np.pi

                # Filter players within the sector
                if abs(angle_diff) <= np.radians(self.angle / 2):
                    dist_to_player = np.sqrt((px - self.ball_x) ** 2 + (py - self.ball_y) ** 2)
                    if dist_to_player <= distance:
                        self.opponents_in_sector.append((angle_diff, dist_to_player))


    def calculate_gaussian_distribution(self, sigma_x=0.2, sigma_y=3):
        # Accumulate Gaussian distribution on the grid based on angle and distance data
        angles = np.array([angle for angle, _ in self.opponents_in_sector])
        distances = np.array([dist for _, dist in self.opponents_in_sector])

        x_bins = np.linspace(-1.5, 1.5, 20)
        y_bins = np.linspace(0, 50, 20)
        Z = np.zeros((len(y_bins) - 1, len(x_bins) - 1))


        # Calculate Gaussian distribution
        for angle, dist in zip(angles, distances):
            for i in range(len(x_bins) - 1):
                for j in range(len(y_bins) - 1):
                    x_center = (x_bins[i] + x_bins[i + 1]) / 2
                    y_center = (y_bins[j] + y_bins[j + 1]) / 2
                    gaussian = np.exp(-(((x_center - angle) ** 2) / (2 * sigma_x ** 2) +
                                        ((y_center - dist) ** 2) / (2 * sigma_y ** 2)))
                    Z[j, i] += gaussian

        self.Z = Z
        self.x_bins = x_bins
        self.y_bins = y_bins


    def get_column_sum(self):
        closest_index = np.abs(self.x_bins - 0).argmin()
        column_sum = self.Z[:, closest_index].sum()
        return column_sum
    
    def calculate_xP(self, distance_lambda_=0.005, column_gamma_=2, sigma_x=0.2, sigma_y=3):
    
        results = []
        column_sums = []      

        distance = np.sqrt((self.teammate['x'] - self.ball_x) ** 2 + (self.teammate['y'] - self.ball_y) ** 2)
        
        # Calculate pressure (column sum)
        self.calculate_opponents_in_sector()
        self.calculate_gaussian_distribution(sigma_x=sigma_x, sigma_y=sigma_y)
        column_sum = self.get_column_sum()
        
        column_sums.append(column_sum)
        results.append({
            "receiver_idx": self.player_idx,
            "distance": distance,
            "column_sum": column_sum,
            "xP": None  # xP will be calculated later
        })

        for result in results:
            # Calculate xP 
            result["xP"] = (
                (1+np.log(-distance_lambda_ * result["distance"]+1))*
                (1/(1+column_gamma_*result["column_sum"]))         
            )
        return results

        
   
@required_fields(["freeze_frame_360", "start_x", "start_y"])
@simple
def get_column_sum_to_player(actions):
    # Initialize a 2D array for storing results with NaN
    results = np.full((len(actions), 10), np.nan, dtype=float)

    for i, (_, action) in enumerate(actions.iterrows()):
        if not action["freeze_frame_360"]:
            continue

        df_freeze_frame = pd.DataFrame.from_records(action["freeze_frame_360"])
        start_x, start_y = action.start_x, action.start_y

        # Filter only opponent players
        opponent_locs = df_freeze_frame[~df_freeze_frame.teammate]
        if opponent_locs.empty:
            continue
        dist_presser_to_target = np.sqrt((opponent_locs.x - start_x) ** 2 + (opponent_locs.y - start_y) ** 2)
        target_idx = dist_presser_to_target.idxmin()
        ball_x, ball_y = opponent_locs.loc[target_idx, ["x", "y"]].values

        freeze_frame = action["freeze_frame_360"]
        possible_reciever = opponent_locs.index.difference([target_idx])


        column_sum_values = []
        for player_idx in possible_reciever:
            sector_analysis = SectorAnalysis(ball_x, ball_y, freeze_frame=freeze_frame, angle=45, player_idx=player_idx, visualize=False)
            
            sector_analysis.calculate_opponents_in_sector()
            sector_analysis.calculate_gaussian_distribution()
            # xp_result = sector_analysis.calculate_xP()
            # xp_values.append({
            #     "player_idx": player_idx,
            #     "distance": np.sqrt((sector_analysis.teammate['x'] - ball_x) ** 2 + (sector_analysis.teammate['y'] - ball_y) ** 2),
            #     "xP": xp_result[0]["xP"]
            # })
            
            column_sum=sector_analysis.get_column_sum()
            column_sum_values.append({
                "player_idx": player_idx,
                "column_sum": column_sum
            })

        # Sort by distance
        column_sum_values = sorted(column_sum_values, key=lambda x: x["column_sum"], reverse=True)

        # Extract xP values and fill NaN array
        column_sum_only = [x["column_sum"] for x in column_sum_values]
        results[i, :len(column_sum_only)] = column_sum_only


    # Convert results to DataFrame
    column_sum_only = [f"column_sum_to_idx{i+1}" for i in range(10)]
    return pd.DataFrame(results, index=actions.index, columns=column_sum_only)

# parameter(radius) set
defenders_in_3m_radius = required_fields(["start_x", "start_y", "end_x", "end_y", "freeze_frame_360"])(
    simple(partial(_opponents_in_radius, radius=3)))
defenders_in_3m_radius.__name__ = "defenders_in_3m_radius"

closest_11_players = required_fields(["freeze_frame_360", "start_x", "start_y"]
)(simple(partial(closest_players, num_players=11)))  # parameter: num_players=11
closest_11_players.__name__ = "closest_11_players"

expected_3_receiver_and_presser_by_distance = required_fields(["freeze_frame_360", "start_x", "start_y"])(
   simple(partial(expected_receiver_and_presser_by_distance, min_players=3)))  # parameter: num_players=3
expected_3_receiver_and_presser_by_distance.__name__ = "expected_3_receiver_and_presser_by_distance"

all_features = [
    actiontype,
    actiontype_onehot,
    result,
    result_onehot,
    bodypart,
    bodypart_onehot,

    time,

    startlocation,
    relative_startlocation,
    endlocation,
    relative_endlocation,

    startpolar,
    endpolar,

    movement,
    team,
    time_delta,
    space_delta,
    goalscore,

    angle,
    under_pressure,
    # packing_rate,
    # ball_height_onehot,

    speed,
    freeze_frame_360,
    # nb_opp_in_path,
    dist_opponent,
    defenders_in_3m_radius,
    # closest_3_players,
    closest_11_players,
    # expected_3_receiver_and_presser_by_distance
    get_column_sum_to_player
]


def get_features(
    db: Database,
    game_id: int,
    xfns: List[Callable] = all_features,
    actionfilter: Optional[Callable] = None,
    nb_prev_actions: int = 3,
):
    """Apply a list of feature generators.

    Parameters
    ----------
    db : Database
        The database with raw data.
    game_id : int
        The ID of the game for which features should be computed.
    xfns : List[Callable], optional
        The feature generators.
    actionfilter : Callable, optional
        A function that filters the actions to be used.
    nb_prev_actions : int, optional
        The number of previous actions to be included in a game state.

    Returns
    -------
    pd.DataFrame
        A dataframe with the features.
    """
    # retrieve actions from database
    
    actions = add_names(db.actions(game_id)).reset_index()

    # filter actions of interest
    if actionfilter is None:
        idx = pd.Series([True] * len(actions), index=actions.index)
    else:
        idx = actionfilter(actions)

    
    # First event that is not under pressure
    actions["last_non_pressing_idx"] = None
    for i, row in actions.iterrows():
        if row["type_name"] != "pressing":  # Non-pressing event
            last_non_pressing = row["action_id"]  # Update last non-pressing action_id
        actions.at[i, "last_non_pressing_idx"] = last_non_pressing

    # check if we have to return an empty dataframe
    if idx.sum() < 1:
        column_names = []
        for fn in xfns:
            column_names.extend(feature_column_names([fn], nb_prev_actions))
        return pd.DataFrame(columns=column_names)
    else:
        pressure_index = actions.loc[idx, ["game_id", "action_id"]].set_index(['game_id', 'action_id']).index
        
    if len(xfns) < 1:
        return pd.DataFrame(index=actions.index.values[idx])
    
    # convert actions to gamestates
    home_team_id, _ = db.get_home_away_team_id(game_id)

    pressure_state = play_left_to_right(gamestates(actions.loc[idx], 1), home_team_id)
    game_states = play_left_to_right(gamestates(actions[actions["type_name"] != "pressing"], nb_prev_actions), home_team_id)

    last_idx = pressure_state[0]["last_non_pressing_idx"].values
    game_states = [s.loc[last_idx] for s in game_states]

    states = pressure_state + game_states
    states = [s.reset_index(drop=True) for s in states]
    
    # compute features
    df_features = reduce(
        lambda left, right: pd.merge(left, right, how="outer", left_index=True, right_index=True),
        (fn(states) for fn in xfns),
    )

    return df_features.set_index(pressure_index)
